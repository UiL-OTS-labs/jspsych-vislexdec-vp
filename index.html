<!DOCTYPE html>
<html>
    <head>
    <meta charset="UTF-8">
    
    <title>Visual Lexical Decision Experiment with Visual Prime</title>

    <script src="https://web-experiments.lab.hum.uu.nl/jspsych/6.1.0/jspsych.js"></script>
    <script src="https://web-experiments.lab.hum.uu.nl/jspsych/6.1.0/plugins/jspsych-html-keyboard-response.js"></script>
    <script src="https://web-experiments.lab.hum.uu.nl/jspsych/6.1.0/plugins/jspsych-html-button-response.js"></script>

    <!-- Generic check/ask libraries (instructions & surveys & consent) -->
    <script src="https://web-experiments.lab.hum.uu.nl/jspsych/6.1.0/plugins/jspsych-instructions.js"></script>
    <script src="https://web-experiments.lab.hum.uu.nl/jspsych/6.1.0/plugins/jspsych-survey-html-form.js"></script>
    <script src="https://web-experiments.lab.hum.uu.nl/jspsych/6.1.0/plugins/jspsych-survey-multi-choice.js"></script>
    <script src="https://web-experiments.lab.hum.uu.nl/jspsych/6.1.0/plugins/jspsych-external-html.js"></script>
    <script src="https://web-experiments.lab.hum.uu.nl/jspsych/6.1.0/plugins/jspsych-survey-multi-select.js"></script>
    
    <!-- Generic jspsych style sheet -->
    <link href="https://web-experiments.lab.hum.uu.nl/jspsych/6.1.0/css/jspsych.css" rel="stylesheet" type="text/css"/>

    <!-- Uil OTS libraries -->
    <script src="https://web-experiments.lab.hum.uu.nl/jspsych/uil-utils/dev/jspsych-uil-utils.js"></script>

    <!-- Uil OTS scripts -->
    <script src="globals.js"></script>
    <script src="consent.js"></script>
    <script src="instructions.js"></script>
    <script src="stimuli.js"></script>
    <script src="survey.js"></script>

    <style>

    .stimulus { 
        font-size: 30px; 
        font-family: monospace;
        font-weight: normal;
    }

    .instruction {
        text-align: left;
        margin: 5% 10% 5% 10%;
    }

    .survey {
        text-align: left;
        margin: 5% 5% 5% 5%;
    }

    .jspsych-survey-multi-choice-question {
        text-align: left;
    }

    .jspsych-survey-multi-choice-text {
        text-align: left;
    }

    .jspsych-survey-multi-choice-option {
        text-align: left;
    }

    kbd {
        border-radius: 2px;
        padding: 2px;
        border: 1px solid black;
    }
    
    input,
    label {
        margin: .4rem 0;
    }

    span::after {
        padding-left: 3%;
    }

    input:invalid + span::after {
        content: '✖';
    }

    input:valid+span::after {
          content: '✓';
    }

    </style>
    </head>
    <body></body>
    <script>
    
    // Wait till the browser has loaded all files, then execute the
    // contents of this method
    
    window.addEventListener('load', function() {

        let stimuli = pickRandomGroup();

        // Experiment logic variables
        // let repeat_consent = false;

        // used by the keyboard validation, overly verbose...
        var repeat_validate_left_key = false;
        var repeat_validate_right_key = false;

        var left_key_confirmed = false;
        var right_key_confirmed = false;
        
        var chosen_keyboard = undefined;
        
        // more abstract yes/no key placeholders 
        //so we don't need switch statements for scoring in 'present_word'
        var yes_key = undefined;
        var no_key = undefined;

        function getLeftOrRightHanded()
        {
            let data = jsPsych.data.get().select('survey_multi_choice_responses');
            console.log(data);
            data = JSON.parse(data.values[0]);
            return data.HandPreference;
        }

        function getCorrectKey()
        {
            let handed = getLeftOrRightHanded().toLowerCase();
            return KEYBOARD_DEFAULTS[chosen_keyboard][handed + '_key'];
        }

        function getIncorrectKey()
        {
            let handed = getLeftOrRightHanded().toLowerCase();
            // If left handed, use right. Otherwise, use left.
            let incorrect_key = (handed == 'left' ? 'right' : 'left') + '_key';
            return KEYBOARD_DEFAULTS[chosen_keyboard][incorrect_key];
        }

        //simple version, single digit input, not a list
        function upperCaseFromASCII(keycode)
        {
            character = String.fromCharCode(keycode);
            return character.toUpperCase();
        }

        // data one would like to add to __all__ trials, according to:
        // https://www.jspsych.org/overview/data/
        let subject_id = jsPsych.randomization.randomID(8);
        let group_name = stimuli.group_name;

        jsPsych.data.addProperties({
            subject: subject_id,
            group: group_name,
        });

        let start_screen = {
            type: 'html-button-response',
            stimulus: function(){
                return "<div class='instruction' >" +
                       "<p>" + GENERIC_CHECK + "</p></div>";
            },
            choices: [OK_BUTTON_TEXT],
            response_ends_trial: true
        };

        let select_keyboard_layout = {
            type: 'html-button-response',
            stimulus: '<h2>Choose the keyboard layout that looks most like yours</h2>',
            choices: KEYBOARD_CHOICES,
            prompt: `
                Focus on the first 6 <strong>letters</strong> in the top left of your
                keyboard layout if you're unsure.
                `,
            button_html: `
                <button class="img-btn">
                <img src=./images/%choice%.png></button>
                `,
            on_finish: function(data) {
                let button_id = data.button_pressed;
                let button_number = parseInt(button_id, 10);
                let keyboard_chosen = KEYBOARD_CHOICES[button_number];
                data.keyboard = keyboard_chosen;
                chosen_keyboard = keyboard_chosen;//setting global value
            }
        };

        //////////// left key setting & validation /////////////////////////

        let test_keyboard_key_left = {
            type: 'html-keyboard-response',
            stimulus: function(){
                return "<class='stimulus'>" +
                       "<p>Press the <kbd>" +
                        KEYBOARD_DEFAULTS[chosen_keyboard]['left_key'] +
                       "</kbd> key on your keyboard.</p>";
            },
            choices: jsPsych.ALL_KEYS,
            response_ends_trial: true,
            stimulus_duration: 10000,
            trial_duration: 10000,
            prompt: "Please respond within 10 seconds.",
            data: {
                trial_phase: 'test_keyboard_key_left'
            },
            loop_function: function(data){
                return repeat_validate_left_key;
            },
            on_finish: function(data) {
                let expected_key_press = 
                    jsPsych.pluginAPI.convertKeyCharacterToKeyCode(
                    KEYBOARD_DEFAULTS[chosen_keyboard]['left_key']
                    );
                let key_chosen_ascii = data.key_press;
                let key_chosen_char = 
                    upperCaseFromASCII(key_chosen_ascii); //blanks for other than 0-9 & A-Z
                data.key_confirmed = data.key_press == expected_key_press;
                data.key_chosen_ascii = key_chosen_ascii;
                data.key_chosen_char = key_chosen_char;

                // We use === instead of a straight assignment to ensure we
                // don't get 'undefined' as a value
                left_key_confirmed = data.key_confirmed === true;
            }
        };

        let if_validated_key_left_feedback_needed = {
            type: 'html-button-response',
            stimulus: function() {
                let wanted_key = KEYBOARD_DEFAULTS[chosen_keyboard]['left_key'];
                let chosen_key = jsPsych.data.getLastTrialData().values()[0].key_chosen_char;
                return "<p> You were asked to press: " + wanted_key + "<BR><BR>" + 
                       "You pressed: " + chosen_key +
                       "<BR><BR>Try again, please...</p>";
            },
            choices: [OK_BUTTON_TEXT]
        };

        let if_key_left_node = {
            timeline: [if_validated_key_left_feedback_needed],
            conditional_function: function(){
                if (left_key_confirmed === true){
                    repeat_validate_left_key = false;
                    return false;
                } else {
                    repeat_validate_left_key = true;
                    return true;
                }
            }
        };

        //////////// right key setting & validation /////////////////////////

        let test_keyboard_key_right = {
            type: 'html-keyboard-response',
            stimulus: function(){
                return "<class='stimulus' >" +
                       "<p>Press the <kbd>" +
                        KEYBOARD_DEFAULTS[chosen_keyboard]['right_key'] +
                       "</kbd> key on your keyboard.</p>";
            },
            choices: jsPsych.ALL_KEYS,
            response_ends_trial: true,
            stimulus_duration: 10000,
            trial_duration: 10000,
            prompt: "Please respond within 10 seconds",
            data: {
                trial_phase: 'test_keyboard_key_right'
            },
            on_finish: function(data) {
                let expected_key_press = 
                    jsPsych.pluginAPI.convertKeyCharacterToKeyCode(
                    KEYBOARD_DEFAULTS[chosen_keyboard]['right_key']
                    );
                let key_chosen_ascii = data.key_press;
                let key_chosen_char = upperCaseFromASCII(key_chosen_ascii);
                data.key_confirmed = data.key_press == expected_key_press;
                data.key_chosen_ascii = key_chosen_ascii;
                data.key_chosen_char = key_chosen_char;

                // We use === instead of a straight assignment to ensure we
                // don't get 'undefined' as a value
                right_key_confirmed = data.key_confirmed === true;
            }
        };

        let if_validated_key_right_feedback_needed = {
            type: 'html-button-response',
            stimulus: function() {
                let wanted_key = KEYBOARD_DEFAULTS[chosen_keyboard]['right_key'];
                let chosen_key = 
                    jsPsych.data.getLastTrialData().values()[0].key_chosen_char;
                return "<p> You were asked to press: " + wanted_key + "<BR><BR>" + 
                       "You pressed: " + chosen_key +
                       "<BR><BR>Try again, please...</p>";
            },
            choices: [OK_BUTTON_TEXT]
        };

        let if_key_right_node = {
            timeline: [if_validated_key_right_feedback_needed],
            conditional_function: function(){
                if (right_key_confirmed == true){
                    repeat_validate_right_key = false;
                    return false;
                } else {
                    repeat_validate_right_key = true;
                    return true;
                }
            }
        };

        let instruction_screen_practice = {
            type: 'html-button-response',
            stimulus: function(){
                let text = PRE_PRACTICE_INSTRUCTION;
                text = text.replace('%correct_key%', getCorrectKey());
                text = text.replace('%incorrect_key%', getIncorrectKey());
                return "<div class='instruction' >" +
                       "<p>" + text + "</p></div>";
            },
            choices: [OK_BUTTON_TEXT],
            response_ends_trial: true,
            post_trial_gap: DEFAULT_ITI
        };

        let participant_keyboard_control_start = {
            type: 'html-keyboard-response',
            stimulus: function(){
                let text = PREPARE_YES_KEY_PROMPT;
                text = text.replace('%correct_key%', getCorrectKey())
                return "<div class='instruction' >" +
                       "<p>" + text + "</p></div>";
            },
            choices: function(){
                let choice = getCorrectKey();
                return [choice];
            },
            //trial_duration: 10000,
            trial_ends_after_response: true,
            post_trial_gap: DEFAULT_ITI
        };

        let well_done_screen = {
            type: 'html-button-response',
            stimulus: function(){
                return "<div class='instruction' >" +
                    '<p>' + PRE_TEST_INSTRUCTION + '</p></div>';
            },
            choices: [OK_BUTTON_TEXT],
            response_ends_trial: true,
            post_trial_gap: DEFAULT_ITI
        };

        let end_screen = {
            type: 'html-button-response',
            stimulus: DEBRIEF_MESSAGE,
            choices: [],
            trial_duration: DEBRIEF_MESSAGE_DURATION
        };

        let present_fixation = {
            type: 'html-keyboard-response',
            stimulus: '<span style="font-size:40px;">+</span>',
            choices: jsPsych.NO_KEYS,
            trial_duration: FIXCROSS_DURATION
        };

        let present_prime = {
            type: 'html-keyboard-response',
            stimulus: function(){
                return "<p class='stimulus'>" + 
                       jsPsych.timelineVariable('prime', true) + "</p>";
            },
            choices: jsPsych.NO_KEYS,
            trial_duration: PRIME_DURATION,
            post_trial_gap: PRIME_GAP_DURATION,
            prompt: ""
        };

        // So this is a hack (or a clever use of Duck Typing)
        // We don't actually know the right keys when defining present_word,
        // but we need to give an array of choices anyway. This object mimics
        // an array just enough to fool JSPsych into accepting it.
        // It works by defining the 0 and 1 'indexes' as getter functions. As
        // JSPsych only uses the array when we already know the keys, the
        // values are only computed once we know them.
        let present_word_choices = {
            _0: undefined,
            _1: undefined,
            get 0() {
                // This is a caching strategy, to ensure we only have to do
                // expensive stuff once
                if (typeof this._0 === 'undefined')
                    this._0 = getCorrectKey();

                return this._0;
            },
            get 1() {
                // This is a caching strategy, to ensure we only have to do
                // expensive stuff once
                if (typeof this._1 === 'undefined')
                    this._1 = getIncorrectKey();
                return this._1;
            },
            length: 2,
        };

        let present_word = {
            type: 'html-keyboard-response',
            stimulus: function(){
                return "<p class='stimulus'>" + jsPsych.timelineVariable('word', true) + "</p>";
            },
            choices: present_word_choices,
            response_ends_trial: true,
            stimulus_duration: WORD_DURATION,
            trial_duration: RESPONSE_TIMEOUT_DURATION,
            post_trial_gap: DEFAULT_ITI,
            prompt: "",
            data: {
                condition: jsPsych.timelineVariable('item_type'),
                word: jsPsych.timelineVariable('word'),
                prime: jsPsych.timelineVariable('prime'),
                id: jsPsych.timelineVariable('id'),
                trial_phase: 'present_word',
                useful_data_flag: true,
                correct_response: jsPsych.timelineVariable('correct')
            },
            on_finish: function(data){
                // Alias this jsPsych function for readability
                let convertToKeyCode = jsPsych.pluginAPI.convertKeyCharacterToKeyCode
                
                //stuff to give values from interactions
                let correct_key = getCorrectKey();
                let incorrect_key = getIncorrectKey();

                let answer;
                let correct;

                // now, if this is the first time, we should set the exp vars
                if ( yes_key == undefined ){
                    yes_key = correct_key;
                }
                
                if ( no_key == undefined ){
                    no_key = incorrect_key;
                }

                // what was/can be chosen
                let key_chosen_ascii = data.key_press;
                let key_chosen_char = upperCaseFromASCII(key_chosen_ascii);
                
                // actual true/false, if any responses...
                if (key_chosen_char == yes_key){
                    answer = 1;
                } else if (key_chosen_char == no_key){
                    answer = 0;
                } else { 
                    answer = undefined;
                };

                correct = answer == data.correct_response;
                // add to output
                data.correct = correct;
                data.key_chosen_ascii = key_chosen_ascii;
                data.key_chosen_char = key_chosen_char;
                data.yes_key = yes_key;
                data.no_key = no_key;
            }
        };

        let present_feedback = {
            type: 'html-keyboard-response',
            stimulus: function() {
                let feedback_text = '<span style="color:red;font-size:30px;">Incorrect</span>';
                let last_resp_acc = jsPsych.data.getLastTrialData().values()[0].correct;
                if (last_resp_acc == true) {
                    feedback_text = '<span style="color:green;font-size:30px;">Correct!</span>';
                }
                return feedback_text;
            },
            choices: jsPsych.NO_KEYS,
            trial_duration: FEEDBACK_DURATION,
        };

        // procedures //////////////////////////////////////////////////////////

        // let survey_procedure = {
        //     timeline: [
        //         survey_multi_html_block,
        //         survey_multi_choice_block,
        //         survey_review_survey_data,
        //     ],
        //     loop_function: function(){
        //         if (repeat_survey == true){
        //             // Remove any previously recorded data, to prevent
        //             // duplicate entries
        //             jsPsych.data.reset();

        //             return true;
        //         } else {
        //             return false;
        //         }
        //     }
        // };

        let keyboard_set_key_left_procedure = {
            timeline:[
                test_keyboard_key_left,
                if_key_left_node,
            ],
            loop_function: function(){
                return repeat_validate_left_key === true;
            }
        }; 

        let keyboard_set_key_right_procedure = {
            timeline:[
                test_keyboard_key_right,
                if_key_right_node,
            ],
            loop_function: function(){
                return repeat_validate_right_key === true;
            }
        }; 

        let practice_procedure = {
            timeline:[
                present_fixation,
                present_prime,
                present_word,
                present_feedback,
            ],
            timeline_variables: getPracticeItems().table,
            randomize_order: false,
        };

        let trial_procedure_pseudorandom = {
            timeline:[
                present_fixation,
                present_prime,
                present_word,
            ],
            timeline_variables: uil.randomization.randomizeStimuli(
                stimuli.table,
                MAX_SUCCEEDING_ITEMS_OF_TYPE,
                'item_type',
            ),
            randomize_order: false // this should be false if uil randomization is used...
        };

        let trial_procedure_random = {
            timeline:[
                present_fixation,
                present_prime,
                present_word,
            ],
            timeline_variables: stimuli.table,
            randomize_order: true // this should be true if you want jsPsych's randomization
        };

        //////////////// timeline /////////////////////////////////

        let timeline = [];

        // it's best practice to have *mouse click* user I/O first
        timeline.push(start_screen);
        
        // Obtain informed consent.
        //timeline.push(consent_trial);

        //timeline.push(consent_page);
        timeline.push(consent_block);

        // survey
        timeline.push(survey_procedure);

        // kb layout
        timeline.push(select_keyboard_layout);
        
        // kb important keys
        timeline.push(keyboard_set_key_left_procedure);
        timeline.push(keyboard_set_key_right_procedure);
        
        // task instruction
        timeline.push(instruction_screen_practice);

        // a keyboard dominant hand configured key continue/prepare flow
        timeline.push(participant_keyboard_control_start);
        
        timeline.push(practice_procedure);
        timeline.push(well_done_screen);

        // "get ready"
        timeline.push(participant_keyboard_control_start);

        // NOTE options below! comment/uncomment for regular vs restrained randomization
        // true randomness is better for the current template's amount of items...

        timeline.push(trial_procedure_pseudorandom); // don't do this with little stimuli
        //timeline.push(trial_procedure_random);
        
        timeline.push(end_screen);

        // Start jsPsych when running on a Desktop or Laptop style pc.
        if (! uil.isMobileOrTablet()) {
            jsPsych.init({
                timeline: timeline,
                exclusions: {
                    min_width: MIN_WIDTH,
                    min_height: MIN_HEIGHT
                },
                on_finish: function() {
                    // the 'true' parameter is needed only for the acc. server
                    uil.saveData(ACCESS_KEY, true);
                }
            });
        }
        else { // or bail out.
            let paragraph = document.createElement("p")
            paragraph.innerHTML = "Please run this experiment on a pc or laptop.";
            document.body.appendChild(paragraph);
        }
    })
    </script>
</html>

